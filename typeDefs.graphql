scalar Date

type Query {
	me: User
	totalStudents: Int!
	allStudents: [Student!]!
	totalUsers: Int!
	allUsers: [User!]!
	classRoster(period: periodName): [Student!]!
	student(_id: ID!): Student!
	lesson(_id: ID!): Lesson!
	findStudentByPeriodAndDesk(period: periodName!, desk: Int!): Student
	numberOfStudentsInCourse(period: periodName): Int!
	findLesson(_id: ID!): Lesson
	findLessonsByUnit(inUnit: String): [Lesson]
	findAllLessons: [Lesson!]
	findUnit(_id: ID!): Unit!
	findUnitsByGrade(gradeLevel: GradeLevelEnum): [Unit!]
	findClassPeriod(period: periodName, assignedDate: Date): ClassPeriod
	findClassPeriods: [ClassPeriod]
	findClassPeriodById(_id: ID!): ClassPeriod!
}

type Mutation {
	createAccount(name: String!, password: String!): User!
	login(name: String!, password: String!): User
	logout: Boolean
	addStudent(input: StudentDetails!): Student!
	removeStudent(_id: ID!): RemoveStudentPayLoad!
	updateStudent(
		_id: ID!
		firstName: String!
		lastName: String!
		responsibilityPoints: Int!
		desk: Int!
		period: periodName!
		teacher: String!
	): Student!
	updateResponsibilityPoints(_id: ID!, responsibilityPoints: Int!): Student!
	hideStudentFromRoster(_id: ID!, isHiddenFromRoster: Boolean!): Student!
	createLesson(input: LessonInput): Lesson!
	createClassPeriod(input: ClassPeriodInput): ClassPeriod
	editLesson(_id: ID!, input: LessonInput): Lesson!
	removeLesson(_id: ID!): RemoveLessonPayLoad!
	createUnit(input: UnitInput): Unit!
	removeUnit(gradeLevel: GradeLevelEnum!, name: String!): RemoveUnitPayLoad!
	removeClassPeriod(_id: ID!): RemoveClassPeriodPayLoad!
	markStudentAbsent(_id: ID!, date: Date): Student
	unduMarkStudentAbsent(_id: ID!, date: Date): Student
	markStudentLate(_id: ID!, date: Date): Student
	unduMarkStudentLate(_id: ID!, date: Date): Student
	# addLessonsToUnit(grade: GradeLevelEnum, lessonName: String):
}

input UnitInput {
	name: String!
	gradeLevel: GradeLevelEnum!
}

type Unit {
	_id: ID!
	name: String!
	hasLessons: [Lesson]
	gradeLevel: GradeLevelEnum!
}

type ClassPeriodPayLoad {
	classPeriod: ClassPeriod
}

type ClassPeriod {
	_id: ID
	grade: GradeLevelEnum
	assignedLesson: Lesson
	assignedDate: Date
	period: periodName
	absentStudents: [Student]
}

input ClassPeriodInput {
	assignedLesson: String
	grade: GradeLevelEnum
	assignedDate: Date
	period: periodName
}

type RemoveLessonPayLoad {
	removed: Boolean!
	lesson: Lesson!
}

type RemoveUnitPayLoad {
	removed: Boolean!
	unit: Unit!
}

type RemoveClassPeriodPayLoad {
	removed: Boolean!
	classPeriod: ClassPeriod!
}

input LessonInput {
	lessonName: String!
	inUnit: String
	essentialQuestion: EssentialQuestionInput
	socraticQuestions: [SocraticQuestionInput]
	studyGuideQuestions: [String]
	vocabWords: [VocabInput]
	readings: ReadingsInput
	workDue: [AssignmentsInput]
	warmup: String!
}

type Lesson {
	_id: ID
	lessonName: String
	inUnit: Unit
	essentialQuestion: EssentialQuestion
	socraticQuestions: [SocraticQuestion]
	studyGuideQuestions: [String]
	vocabWords: [Vocab]
	readings: Readings
	workDue: [Assignments]
	warmup: String
}

type SocraticQuestion {
	type: socraticQuestionsTypeEnum!
	question: String!
}

enum GradeLevelEnum {
	EIGHTH
	SEVENTH
	SIXTH
}

input AssignmentsInput {
	type: AssignmentType!
	readingPages: String
	readingSections: String
	dueDate: Date
}

enum AssignmentType {
	OEQ
	THINKING_GUIDE
	BLOG
}

type Assignments {
	type: AssignmentType!
	dueDate: Date!
	readingPages: String
	readingSections: String
}

type Readings {
	pages: String
	sections: String
}

input ReadingsInput {
	pages: String!
	sections: String!
}

input VocabInput {
	word: String!
	partOfSpeech: partsOfSpeechEnum!
	definition: String!
}

enum partsOfSpeechEnum {
	NOUN
	VERB
	ADJECTIVE
	ADVERB
	PREPOSITION
	PRONOUN
	INTERJECTION
	CONJUNCTION
}

input EssentialQuestionInput {
	type: essentialQuestionTypeEnum!
	textStructure: majorTextStructureEnum!
	question: String!
}

input SocraticQuestionInput {
	type: socraticQuestionsTypeEnum!
	question: String!
}

enum socraticQuestionsTypeEnum {
	CONCEPTUAL_CLARIFICATION
	PROBING_ASSUMPTIONS
	PROBING_RATIONALE_REASONS_EVIDENCE
	QUESTIONING_VIEWPOINTS_AND_PERSPECTIVE
	PROBING_IMPLICATIONS_AND_CONSEQUENCES
	QUESTION_THE_QUESTION
}

enum essentialQuestionTypeEnum {
	HOW
	WHY
}

type EssentialQuestion {
	type: essentialQuestionTypeEnum!
	textStructure: majorTextStructureEnum!
	question: String!
}

type RemoveStudentPayLoad {
	removed: Boolean
	student: Student!
}

# input CreateAccountInput {
# 	id: ID!
# 	name: String!
# 	password: String!
# }

# type LoginPayload {
# 	user: User
# 	token: String!
# }

type User {
	_id: ID!
	name: String!
}

enum periodName {
	A12
	B12
	A34
	B34
	A67
	B67
}

type Student {
	_id: ID!
	firstName: String!
	lastName: String!
	responsibilityPoints: Int!
	period: periodName!
	desk: Int!
	teacher: String!
	isHiddenFromRoster: Boolean!
	daysAbsent: [Date]
	daysLate: [Date]
}

type SchoolDayInfo {
	_id: ID!
	date: String!
	number: Int!
	markingPeriod: markingPeriods!
}

input QuestionInput {
	type: String
	question: String
}

type Vocab {
	word: String
	partOfSpeech: String
	definition: String
}

type Questions {
	type: String
	question: String
	# majorTextStructure: majorTextStructures!
	# minorTextStructure: [minorTextStructures]
}

enum majorTextStructureEnum {
	CAUSE_AND_EFFECT
	CAUSE
	EFFECT
	PROBLEM_AND_SOLUTION
	PROBLEM
	SOLUTION
}

enum markingPeriods {
	FIRST
	SECOND
	THIRD
	FOURTH
}

input StudentDetails {
	firstName: String!
	lastName: String!
	responsibilityPoints: Int!
	period: periodName!
	desk: Int!
	teacher: String!
	isHiddenFromRoster: Boolean!
}

type Teacher {
	name: String!
	teachesCourses: [Course!]!
}

type Course {
	name: String!
	section: String!
	period: periodName!
	hasTeacher: Teacher!
	isEmpty: Boolean!
	roster: [Student]
	assignmentList: [Assignments]
}
